##File name: ampCounter.R
##Creation date: Jun 15, 2015
##Last modified: Mon Aug 31, 2015  10:00AM
##Created by: scott
##Summary: Functions to count fold amplification expected for multiple strand displacement


#' Enumerate the multiple strand displacement fragments generated given a set of primers
#' 
#' Take two vectors of forward and reverse primer binding locations
#' generate a list of amplification products predicted to be
#' generated by multiple strand displacement amplification.
#'
#' @param forwards Sorted positions of primers landing sites on the forward strand of the target sequence.
#' @param reverses Sorted positions of primers landing sites on the reverse strand of the target sequence.
#' @param strand "+" or "-" for indicating what strand the target sequence originates from. Note if starting with double stranded fragments then the function should be run once with "+" and once with "-" and the results concatenated.
#' @param expectedLength The expected max length fragment the polymerase can generate in one run.
#' @param minLength Discard fragments shorter than minLength (can help with run time if many short fragments are generated)
#' @param maxTotalLength Discard fragments for which the sum of all the ancestors bases are longer than maxTotalLength. If the polymerase has some probability of falling off each base amplified then it becomes less and less likely to reach a deeply amplified product. Using maxTotalLength to end the recursion once a certain total length is reach can help with run time.
#' @param vocal TRUE or FALSE Output progress?
#' @param fragmentStart The 5' end of the current fragment (for use in recursion more than manually)
#' @param fragmentEnd The 3' end of the current fragment (for use in recursion more than manually)
#' @param baseName Prefix for tracking fragment ancestors (for use in recursion more than manually)
#' @param previousLength How many bases need to be amplified to reach this fragment (for use in recursion more than manually)
#'
#' @return A data frame with columns start, end, strand, name, previousLength and length. Start and end and strand are the positions of 5' and 3' end on the appropriate strand of the target sequence. Name is a concatenation of the ancestors of that fragment. Previous length is the sum of the fragment lengths of the ancestors of this fragment. Length is the width of this fragment.
#'
#' @concept multiple strand displacement amplification fragment prediction recursive recursion
#'
#' @seealso \url{https://en.wikipedia.org/wiki/Multiple_displacement_amplification}
#' @seealso \code{\link{countAmplifications}}
#'
#' @export
#' 
#' @examples
#' enumerateAmplifications(c(10,20,30),c(40,50,60))
enumerateAmplifications<-function(forwards,reverses,strand='+',expectedLength=50000,minLength=1,maxTotalLength=Inf,fragmentStart=1,fragmentEnd=Inf,baseName='',vocal=FALSE,previousLength=0){
	if(vocal&&runif(1)<.001)cat('.')
	if(vocal&&runif(1)<.0001)cat(sprintf(' %d ',fragmentStart))
	if(any(diff(forwards)<1)||any(diff(reverses)<1))stop(simpleError('Expects sorted primer positions')) #could handle ahead of time
	if(strand=='+'){
		thisStarts<-forwards[forwards>=fragmentStart&forwards<=fragmentEnd] #ignores primer length for now
		if(length(thisStarts)==0)return(NULL)
		thisEnds<-thisStarts+expectedLength
		thisEnds[thisEnds>=fragmentEnd]<-fragmentEnd
		isTerminal<-diff(c(-Inf,thisStarts))>expectedLength
	}else{
		thisEnds<-reverses[reverses>=fragmentStart&reverses<=fragmentEnd] #ignores primer length for now
		if(length(thisEnds)==0)return(NULL)
		thisStarts<-thisEnds-expectedLength
		thisStarts[thisStarts<=fragmentStart]<-fragmentStart
		isTerminal<-diff(c(thisEnds,Inf))> expectedLength
	}
	nFrags<-length(thisStarts)
	nDigits<-ceiling(log10(nFrags+1))
	sprintfPattern<-sprintf('%%s%s%%0%dd',ifelse(baseName=='','','_'),nDigits)
	out<-data.frame(
		'start'=thisStarts,
		'end'=thisEnds,
		'strand'=strand,
		'name'=sprintf(sprintfPattern,baseName,1:nFrags),
		'previousLength'=previousLength,
		'length'=thisEnds-thisStarts+1,
		stringsAsFactors=FALSE
	)
	#filter out shorts
	out<-out[out$length>=minLength,]
	#terminate fragments with too many amplifications to have much weight
	isTerminal<-isTerminal|out$previousLength+out$length>=maxTotalLength
	if(any(!isTerminal)){
		daughters<-do.call(rbind,mapply(function(start,end,name){
			countAmplifications(forwards, reverses, strand=ifelse(strand=='+','-','+'), start, end, expectedLength=expectedLength, baseName=name,vocal=vocal,previousLength=previousLength+end-start+1,maxTotalLength=maxTotalLength)
		},
		out[!isTerminal,'start'],out[!isTerminal,'end'],out[!isTerminal,'name'],SIMPLIFY=FALSE))
		out<-rbind(out,daughters)
	}
	return(out)
}

#' Plot fragments generated from multiple strand displacement
#' 
#' Take a data.frame with columns start, end, strand  (e.g. the output of \code{\link{enumerateAmplifications}}) and plot
#' an arrow representation of the fragments to the current device.
#'
#' @param frags A data.frame with columns start, end, strand  (and name if label is TRUE) e.g. the output of \code{\link{enumerateAmplifications}}
#' @param label TRUE or FALSE if fragments should be labeled with name from the name column of frags
#'
#' @return NULL. Draws plot to current device
#'
#' @concept multiple strand displacement amplification fragment plot arrows 
#'
#' @seealso \code{\link{enumerateAmplifications}}
#'
#' @export
#' 
#' @examples
#' frags<-enumerateAmplifications(c(10,20,30),c(40,50,60))
#' plotFrags(frags)
plotFrags<-function(frags,label=TRUE){
	nFrags<-nrow(frags)
	plot(1,1,type='n',xlim=range(frags[,c('start','end')]),ylim=c(1,nFrags)+c(-.5,.5),xlab='Genome position (nt)',ylab='Fragment',yaxs='i')
	arrows(ifelse(frags$strand=='+',frags$start,frags$end),1:nFrags,ifelse(frags$strand=='+',frags$end,frags$start),1:nFrags,length=.02)
	if(label)text(apply(frags[,c('start','end')],1,mean),1:nFrags,frags$name,col='#00000077',adj=c(0.5,0),cex=.6)
	return(NULL)
}

#' Generate random primers for testing
#' 
#' Generate random position for primers. Mostly for internal testing and examples
#'
#' @param genomeSize Max position for primers
#' @param frequency About how much space between primers. Function will generate approximately genomeSize/frequency primers
#'
#' @return sorted list of positions
#'
#' @keywords internal
#'
#' @examples
#' generateRandomPrimers(10000,100)
generateRandomPrimers<-function(genomeSize,frequency){
	nPrimers<-round(genomeSize/frequency)
	out<-unique(sort(ceiling(runif(nPrimers,1,genomeSize))))
	return(out)
}

#inefficient coverage count 
#starts:starts of coverage ranges
#ends:ends of coverage ranges
countCover<-function(starts,ends,strands=rep('+',length(starts)),stayOnRate=1,perBaseWeights=stayOnRate^(0:max(ends-starts)),fragmentWeights=stayOnRate^fragmentTotalBases,fragmentTotalBases=rep(0,length(starts)),vocal=FALSE,coverEnd=max(ends)){
	if(any(ends-starts+1>length(perBaseWeights)))stop(simpleError('Fragment found longer than weight vector'))
	if(any(ends>coverEnd))stop(simpleError('Fragment ends extend beyond max length'))
	cover<-rep(0,coverEnd)	 #bad for big empty genome
	mapply(function(start,end,strand,weight){
		if(vocal)if(runif(1)<.0001)cat('.')
		revFunc<-ifelse(strand=='+',c,rev)
		cover[start:end]<<-cover[start:end]+perBaseWeights[revFunc(1:(end-start+1))]*weight
		return(NULL)
	},starts,ends,strands,fragmentWeights) #global abuse
	return(cover)
}

#' Fast calculation of expected multiple strand displacement amplification
#' 
#' Uses dynamic programing to build a matrix of the expected amplifications for positions with a given a number 
#' of forward primers upstream and reverse primers downstream and within range of the polymerase.
#'
#' @param nForwards Calculate a matrix from zero to this many forward primers
#' @param nReverses Calculate a matrix from zero to this many reverse primers
#'
#' @return A nForwards+1 row, nReverses+1 column matrix of the expected amplifications for each combination of numbers
#' of forward and reverse primers. Row 1 is for 0 forward primers within range, row 2 is for 1 forward primer,
#' column 1 is for 0 reverse primers, column 2 is for 1 reverse primers ...
#'
#' @concept multiple strand displacement amplification fragment prediction dynamic programming
#'
#' @seealso \code{\link{enumerateAmplifications}}
#'
#' @export
#' 
#' @examples
#' generateAmplificationTable(20,20)
generateAmplificationTable<-function(nForwards=10,nReverses=10){
	out<-matrix(NA,nrow=nForwards+1,ncol=nReverses+1)
	rownames(out)<-0:nForwards
	colnames(out)<-0:nReverses
	out['0',]<-0
	out['1',]<-1
	out[,'0']<-0:nForwards
	out[1+1:nForwards,'1']<-out[1+1:nForwards,'0']*2-1
	for(ii in 1+2:nForwards){
		for(jj in 1+2:nReverses){
			out[ii,jj]<-out[ii-1,jj]+out[ii,jj-1]+1
		}
	}
	return(out)
}

#' Calculate expected multiple strand displacement amplification using lookup table
#' 
#' Uses the amplificationLookup table stored in the package data to predict amplification based on the number of forward and reverse primers spanning a region. To keep the lookup table small, I limited this to 1000 forward and reverse primers but it could be extended easily. 
#'
#' @param nForwards Calculate the expected amplifcations for a region with nForwards primers 5' on the correct strand and within range
#' @param nReverses Calculate the expected amplifcations for a region with nReverses primers 3' on the correct strand and within range
#'
#' @return The number of expected amplifications
#'
#' @concept multiple strand displacement amplification fragment prediction dynamic programming
#'
#' @export
#' 
#' @examples
#' countAmplifications(20,20)
#' countAmplifications(0,20)
#' countAmplifications(20,0)
countAmplifications<-function(nForwards,nReverses){
	if(nForwards>1000)stop(simpleError(sprintf('To avoid a large lookup table countAmplifications limited to less than 1000 forward primers. Maybe use generateAmplificationTable(%d,%d) directly',nForwards,nReverses)))
	if(nReverses>1000)stop(simpleError(sprintf('To avoid a large lookup table countAmplifications limited to less than 1000 reverse primers. Maybe use generateAmplificationTable(%d,%d) directly',nForwards,nReverses)))
	amplificationLookup[nForwards+1,nReverses+1]
}


#' Lookup table for predicted amplifcation 
#'
#' A 1001x1001 matrix of predicted amplification for regions spanned by 0-1000 primers
#'
#' @format A 1001 row, 1001 column matrix of the expected amplifications for each combination of 0-1000
#' forward and reverse primers spanning a region. Row 1 is for 0 forward primers within range, row 2 is for 1 forward primer,
#' column 1 is for 0 reverse primers, column 2 is for 1 reverse primers ...
#' @source countAmplifications(1000,1000)
"amplificationLookup"
